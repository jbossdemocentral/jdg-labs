:source-highlighter: coderay
:toc: manual
:toc-placement: preamble
:infinispanQueryGuide: http://red.ht/1nSniBo[See the Infinispan Query Guide]

JBoss Data Grid lab guides: Lab 2
==================================
Thomas Qvarnstr√∂m <tqvarnst@redhat.com>
v1.1 2015-12-06

This guide explains the steps for running lab 2.  Either follow the steps in the step-by-step section or if you feel adventurous try to accomplish goals without the step-by-step guide.

:numbered:

== Background
In lab 1 we implemented a side cache using JDG to speed up reads, but the master data store is still the database. 
So far however the data access is only a using the common CRUD (Create, Read, Update and Delete) operations. 
Since JDG primary are a key/value store these operations are easy to implement.

A competing vendor that has a similar task management solution released a new feature where users can filter their tasks, 
something our customers has been requesting for a while. Our marketing director demands that we ASAP add this feature. 
An external consultant was  hired to implement this feature, but since he wasn't familiar with JDG he implemented the 
filter solution using JPA query. However, this is not responsive enough and we need to refactor the filter function to query JDG instead.

JDG has very advanced querying capabilities available in both library mode and client/server mode.

== Use-case
You are tasked to rewrite the filter implementation using queries in JDG instead of JPA queries. However, the Task data model is used in 
the native mobile application.  Since it will take a while before we can update the mobile application you are not allowed to change 
the org.jboss.infinspan.demo.model.Task class.

== Objectives
Your task in lab 2 is to re-implement the filtering method, but using JDG Queries.
The UI and REST methods are already implemented.

Basically you should replace the DB Query with a JDG Query and you will have to
do this without modifying the org.jboss.infinspan.demo.model.Task class.

To do this we need to do the following:

1. Setup the lab environment
1. Add developer dependencies:
    Update the pom.xml and add developer dependency to infinispan-query
2. Add runtime dependencies
    Update jboss-deployment-structure.xml to add runtime dependency to infinispan-query
3. Update configuration
    Enable indexing in the API Configuration. Hint {infinispanQueryGuide} 
      - The index should only be persisted in RAM
      - Since we will later deploy this on mulitple EAP instances we need to allow for shared indexes.
      - The index should be based on the `title` field from `org.jboss.infinspan.demo.model.Task`
4. Write the implementation to Query JDG
    Replace the implementation of `TaskSerivce.filter(String)` to query JDG instead of DB

== Step-by-Step

=== Setup the lab environment
To assist with setting up the lab environment we have provided a shell script that does this.

NOTE: If you previously setup up lab 1 using this script there is no need to do this for lab 2

1. Run the shell script by standing in the jdg lab root directory (~/jdg-labs) execute a command like this
+
[source,bash]
$ sh init-lab.sh --lab=2

=== Add developer dependencies

1. Open the lab2 pom.xml (see below)
1. Select the `pom.xml` tab
1. Add the `infinispan-embeddded-query` dependency. The content of the file should look like this:
+
[source,xml,indent=0]
----
<?xml version="1.0" encoding="UTF-8"?>
<project
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"
    xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.redhat.jdg.workshop</groupId>
        <artifactId>lab-parent</artifactId>
        <version>1.0.0</version>
        <relativePath>../parent</relativePath>
    </parent>
    <artifactId>lab2</artifactId>
    <packaging>war</packaging>
    <dependencies>
        <dependency>
            <groupId>org.infinispan</groupId>
            <artifactId>infinispan-embedded-query</artifactId>
            <scope>provided</scope>
        </dependency>
    </dependencies>
</project>
----

1. Save the pom.xml file.

=== Add runtime dependencies

1. Open `src/main/webapp/WEB-INF/jboss-deployment-structure.xml`
1. Add `org.infinispan.query` module. The content of the file should look like this:
+
[source,xml,indent=0]
----
<jboss-deployment-structure>
    <deployment>
        <exclusions>
            <module name="org.infinispan" />
        </exclusions>
        <dependencies>
            <module name="org.hibernate" />
            <module name="org.infinispan" slot="jdg-6.5" services="import"/>
            <module name="org.infinispan.cdi" slot="jdg-6.5" meta-inf="import"/>
            <module name="org.infinispan.query" slot="jdg-6.5" services="import"/>
        </dependencies>
    </deployment>
</jboss-deployment-structure>
----
1. After saving It's recommended to run the *JUnit* test to verify that everything deploys fine.

=== Update the configuration

1. Open `src/main/java/org/jboss/infinispan/demo/Config.java`
1. After the global configuration we need to create a `SearchMapping` object that tells JDG how to index `Task` objects
+
[source,java,indent=0]
----
SearchMapping mapping = new SearchMapping();
mapping.entity(Task.class).indexed().providedId()
    .property("title", ElementType.METHOD).field();
----
1. Create a `Properties` object and store the `SearchMapping` object under the `org.hibernate.search.Environment.MODEL_MAPPING` key.
+
[source,java,indent=0]
----
Properties properties = new Properties();
properties.put(org.hibernate.search.Environment.MODEL_MAPPING, mapping);
----
1. We also need to tell JDG (or Lucene) to store the indexes in ram memory by adding a property with key "default.directory_provider" and value "key".
+
[source,java]
----
properties.put("default.directory_provider", "ram");
----
1. Now we can enable the index on the `Configuration` object by adding `.indexing().enable()` to the fluid API before `.build()`.
1. Also we want to configure the index to support clustering adding `.indexLocalOnly(false)` to the fluid API before `.build()`.
1. And finally we want to pass in the properties configuration by adding `.withProperties(properties)` to the fluid API before `.build()`. The config class should now look like this:
+
[source,java,indent=0]
----
package org.jboss.infinispan.demo;

import java.lang.annotation.ElementType;
import java.util.Properties;
import javax.enterprise.context.ApplicationScoped;
import javax.enterprise.inject.Produces;
import org.hibernate.search.cfg.SearchMapping;
import org.infinispan.configuration.cache.Configuration;
import org.infinispan.configuration.cache.ConfigurationBuilder;
import org.infinispan.configuration.global.GlobalConfiguration;
import org.infinispan.configuration.global.GlobalConfigurationBuilder;
import org.infinispan.eviction.EvictionStrategy;
import org.infinispan.manager.DefaultCacheManager;
import org.infinispan.manager.EmbeddedCacheManager;
import org.infinispan.transaction.LockingMode;
import org.infinispan.transaction.TransactionMode;
import org.jboss.infinispan.demo.model.Task;

public class Config {
    @Produces
    @ApplicationScoped
    public EmbeddedCacheManager defaultEmbeddedCacheConfiguration() {
        GlobalConfiguration glob = new GlobalConfigurationBuilder()
                .globalJmxStatistics().allowDuplicateDomains(true).enable() // This
                // method enables the jmx statistics of the global
                // configuration and allows for duplicate JMX domains
                .build();
        
        // SearchMapping tells JDG how to index Task objects
        SearchMapping mapping = new SearchMapping();
        mapping.entity(Task.class).indexed().providedId()
            .property("title", ElementType.METHOD).field();
        
        // Store the SearchMapping in a Properties object with a model mapping key
        Properties properties = new Properties();
        properties.put(org.hibernate.search.Environment.MODEL_MAPPING, mapping);
        // Also tell JDG how to store the index
        properties.put("default.directory_provider", "ram");
        
        Configuration loc = new ConfigurationBuilder().jmxStatistics()
                .enable() // Enable JMX statistics
                .eviction().strategy(EvictionStrategy.NONE) // Do not evic objects
                .transaction().transactionMode(TransactionMode.TRANSACTIONAL)
                .lockingMode(LockingMode.OPTIMISTIC)
                .indexing()
                    .enable()  // Enable indexing
                    .indexLocalOnly(false) // Support clustering 
                    .withProperties(properties)  // Add the properties for indexing
                .build();
        return new DefaultCacheManager(glob, loc, true);
    }
}
----

=== Write the implementation to Query JDG

1. Open `src/main/java/org/jboss/infinispan/demo/TaskService.java`
1. Navigate to the `public Collection<Task> filter(String input)` and delete the current DB implementation
1. In order create QueryBuilder and run that query we need a `SearchManager` object. We can get that by calling `Search.getSearchManager(cache)`
+
[source,java]
----
SearchManager sm = Search.getSearchManager(cache);
----
1. To create a `QueryBuilder` object we can then get a `SearchFactory` from the `SearchManager` and call `buildQueryBuilder().forEntity(Task.class).get()` on it.
+
[source,java]
----
QueryBuilder qb = sm.getSearchFactory().buildQueryBuilder().forEntity(Task.class).get();
----
NOTE: See the last step for a list of the proper imports to use.
+
1. Now we can create a `Query` object from the `QueryBuilder` using the fluid api to specify which Field to match etc.
+
[source,java]
----
Query q = qb.keyword().onField("title").matching(input).createQuery();
----
1. We can now get a `CacheQuery` object by using the `SearchManager.getQuery(...)` method.
+
[source,java]
----
CacheQuery cq = sm.getQuery(q, Task.class);
----
1. The `CacheQuery` extends `Iterable<Object>` directly, but since we are expecting a `Collection<Task>` to return we will have to call `CacheQuery.list()` to get a `List<Object>` back. This will now have to be cast to typed Collection using double Casting.
+
[source,java]
----
return (Collection<Task>)(List)cq.list();
----
Note that since we are using a QueryBuilder specifically for Task.class we can safely do this cast.

1. You also need to add the following import statement if you IDE doesn't fix that
+
[source,java]
----
import org.apache.lucene.search.Query;
import org.hibernate.search.query.dsl.QueryBuilder;
import org.infinispan.query.Search;
import org.infinispan.query.CacheQuery;
----

=== Test and deploy
Run the Arquillian tests.

1. If everything is green we are ready to deploy the application with the following command in a terminal
+
[source,bash,indent=0]
----
    $ mvn package jboss-as:deploy
----

1. Test the application by opening a browser window to http://localhost:8080/mytodo

1. Try the filter and notice the that it responds very fast.
1. Congratulations you are done with lab2.
